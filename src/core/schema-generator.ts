/* eslint-disable @typescript-eslint/no-explicit-any */

import path from "path";
import chalk from "chalk";
import dotenv from "dotenv";
import { FileService } from "../utils/file.js";
import { ToRelativePosixPath } from "../utils/utils.js";

export async function GenerateSchemaFile(envPath: string, outputPath: string): Promise<void> {
  const fileService = FileService.getInstance();

  console.log(chalk.cyan(`üìñ Reading .env file from: ${chalk.yellow(envPath)}`));

  if (!fileService.exists(envPath)) {
    console.error(chalk.red(`‚ùå .env file not found at path: ${envPath}`));
    process.exit(1);
  }

  const envContent = fileService.readFile(envPath);
  const parsed = dotenv.parse(envContent);

  console.log(chalk.cyan(`üîç Parsed ${Object.keys(parsed).length} environment variables`));

  // Step 1 ‚Äî Infer variable types intelligently
  const inferredSchema = inferEnvSchema(parsed);

  // Step 2 ‚Äî Generate TypeScript file content
  const schemaContent = generateTypeScriptSchema(inferredSchema, parsed);

  // Step 3 ‚Äî Ensure output directory exists and write the file
  const absoluteOutput = path.resolve(outputPath);
  fileService.writeFile(absoluteOutput, schemaContent);

  const relativeOutput = ToRelativePosixPath(absoluteOutput);
  console.log(
    chalk.green(`‚úÖ Schema file generated successfully: ${chalk.bold(relativeOutput)}\n`)
  );
}

/**
 * Infers an intelligent schema from parsed .env values
 */
function inferEnvSchema(parsed: Record<string, string>) {
  const schema: Record<string, any> = {};

  for (const [key, value] of Object.entries(parsed)) {
    let fieldType: string = "String";

    if (isBoolean(value)) fieldType = "Boolean";
    else if (isNumber(value)) fieldType = "Number";
    else if (isPort(value)) fieldType = "Port";
    else if (isEmail(value)) fieldType = "Email";
    else if (isUrl(value)) fieldType = "Url";
    else if (isJson(value)) fieldType = "Json";
    else if (isUUID(value)) fieldType = "UUID";
    else if (isArray(value)) fieldType = "Array";

    schema[key] = {
      type: fieldType,
      required: true,
      description: `Environment variable: ${key}`,
    };
  }

  return schema;
}

/**
 * Generates a complete TypeScript schema file string
 */
function generateTypeScriptSchema(
  schema: Record<string, any>,
  parsed: Record<string, string>
): string {
  const lines: string[] = [];
  lines.push(`/* eslint-disable @typescript-eslint/no-explicit-any */ \n`);
  lines.push(`// ‚ö° Auto-generated by env-checkup`);
  lines.push(`// Generated on ${new Date().toISOString()}`);
  lines.push(`// File Suppose to be edited manually for custom validation checks \n`);
  lines.push(`import type { TEnvSchema } from "env-checkup";\n`);

  // EnvSchema (metadata)
  lines.push(`export const EnvSchema: TEnvSchema = {`);
  for (const [key, meta] of Object.entries(schema)) {
    lines.push(`  ${key}: ${formatSchemaField(meta)},`);
  }
  lines.push(`};\n`);

  // EnvSchemaValues (type-safe mapping)
  lines.push(`export interface EnvSchemaValues {`);
  for (const [key, meta] of Object.entries(schema)) {
    lines.push(`  ${key}: ${mapFieldTypeToTs(meta.type)};`);
  }
  lines.push(`}\n`);

  // EnvDefaults (actual parsed values)
  lines.push(`export const EnvDefaults: EnvSchemaValues = {`);
  for (const [key, value] of Object.entries(parsed)) {
    lines.push(`  ${key}: ${formatDefaultValue(value)},`);
  }
  lines.push(`};`);

  return lines.join("\n");
}

function formatSchemaField(meta: any): string {
  const parts: string[] = [];
  parts.push(`{ type: "${meta.type}"`);
  if (meta.description) parts.push(`description: "${meta.description}"`);
  if (meta.required !== undefined) parts.push(`required: ${meta.required}`);
  return parts.join(", ") + " }";
}

function mapFieldTypeToTs(type: string): string {
  switch (type) {
    case "Boolean":
      return "boolean";
    case "Number":
      return "number";
    case "Port":
      return "number";
    case "Array":
      return "string[]";
    case "Json":
      return "Record<string, any>";
    case "UUID":
      return "string";
    case "Email":
      return "string";
    case "Url":
      return "string";
    default:
      return "string";
  }
}

function formatDefaultValue(value: string): string {
  if (isBoolean(value)) return value === "true" ? "true" : "false";
  if (isNumber(value)) return value;
  if (isJson(value)) return JSON.stringify(JSON.parse(value), null, 2);
  if (isArray(value)) return JSON.stringify(value.split(","), null, 2);
  return JSON.stringify(value);
}

// ---------- Type inference helpers ----------

const isBoolean = (v: string) => v === "true" || v === "false";
const isNumber = (v: string) => !isNaN(Number(v)) && v.trim() !== "";
const isPort = (v: string) => isNumber(v) && Number(v) >= 0 && Number(v) <= 65535;
const isEmail = (v: string) => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v);
const isUrl = (v: string) => /^https?:\/\/[^\s/$.?#].[^\s]*$/.test(v);
const isJson = (v: string) => {
  try {
    const obj = JSON.parse(v);
    return typeof obj === "object";
  } catch {
    return false;
  }
};
const isUUID = (v: string) =>
  /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(v);
const isArray = (v: string) => v.includes(",") && !v.includes("=");
